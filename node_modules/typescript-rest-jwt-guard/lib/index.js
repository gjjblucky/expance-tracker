"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JwtBodyGuard = exports.JwtHeaderGuard = exports.JwtCookieGuard = void 0;
const typescript_rest_1 = require("typescript-rest");
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
/**
 * Get token name and value from string.
 *
 * @param {string} str String to retrieve values from.
 */
function retrievePair(str) {
    return str.trim().replace(/\s+/g, ' ').split(' ');
}
/**
 * Check if the request context is provided.
 *
 * @param {object|undefined} context Request context
 */
function checkContext(context) {
    if (!context) {
        throw new typescript_rest_1.Errors.InternalServerError('No context provided.');
    }
}
/**
 * Check if JWT secret is defined.
 */
function checkSecret() {
    if (!process.env.JWT_SECRET) {
        throw new typescript_rest_1.Errors.InternalServerError('Token secret not provided at server.');
    }
}
/**
 * JWT-checking decorator to be used with typescript-rest as annotation.
 * Used when JWT is passed with cookies.
 */
function JwtCookieGuard(tokenName) {
    return (_target, _key, descriptor) => {
        const original = descriptor.value;
        // eslint-disable-next-line
        descriptor.value = function (...args) {
            const context = args.find((arg) => arg instanceof typescript_rest_1.ServiceContext);
            checkContext(context);
            const accessToken = context.request.cookies[tokenName];
            if (!accessToken) {
                throw new typescript_rest_1.Errors.UnauthorizedError(`No '${tokenName}' access token provided.`);
            }
            checkSecret();
            try {
                jsonwebtoken_1.default.verify(accessToken, process.env.JWT_SECRET);
            }
            catch (error) {
                throw new typescript_rest_1.Errors.ForbiddenError('Invalid or expired JWT provided.');
            }
            return original.apply(this, args);
        };
    };
}
exports.JwtCookieGuard = JwtCookieGuard;
/**
 * JWT-checking decorator to be used with typescript-rest as annotation.
 * Used when JWT is passed with authorization header.
 */
function JwtHeaderGuard(tokenName) {
    return (_target, _key, descriptor) => {
        const original = descriptor.value;
        // eslint-disable-next-line
        descriptor.value = function (...args) {
            const context = args.find((arg) => arg instanceof typescript_rest_1.ServiceContext);
            checkContext(context);
            const authHeader = context.request.headers['authorization'];
            if (!authHeader) {
                throw new typescript_rest_1.Errors.UnauthorizedError('No authorization header provided.');
            }
            const [headerTokenName, token] = retrievePair(authHeader);
            if (!headerTokenName || !token) {
                throw new typescript_rest_1.Errors.UnauthorizedError('Incorrect authorization token value.');
            }
            if (headerTokenName !== tokenName) {
                throw new typescript_rest_1.Errors.UnauthorizedError(`Token name '${headerTokenName}' is not the one that is expected: '${tokenName}'.`);
            }
            checkSecret();
            try {
                jsonwebtoken_1.default.verify(token, process.env.JWT_SECRET);
            }
            catch (error) {
                throw new typescript_rest_1.Errors.ForbiddenError('Invalid or expired JWT provided.');
            }
            return original.apply(this, args);
        };
    };
}
exports.JwtHeaderGuard = JwtHeaderGuard;
/**
 * JWT-checking decorator to be used with typescript-rest as annotation.
 * Used when JWT is passed with request post body data.
 */
function JwtBodyGuard(tokenKey) {
    return (_target, _key, descriptor) => {
        const original = descriptor.value;
        // eslint-disable-next-line
        descriptor.value = function (...args) {
            const context = args.find((arg) => arg instanceof typescript_rest_1.ServiceContext);
            checkContext(context);
            const body = context.request.body || {};
            if (!(tokenKey in body)) {
                throw new typescript_rest_1.Errors.UnauthorizedError(`Request body does not contain '${tokenKey}' key.`);
            }
            checkSecret();
            try {
                jsonwebtoken_1.default.verify(body[tokenKey], process.env.JWT_SECRET);
            }
            catch (error) {
                throw new typescript_rest_1.Errors.ForbiddenError('Invalid or expired JWT provided.');
            }
            return original.apply(this, args);
        };
    };
}
exports.JwtBodyGuard = JwtBodyGuard;
//# sourceMappingURL=index.js.map